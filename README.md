# 컴퓨터 구조
## 컴퓨터의 정의

  * 전자 회로를 이용하여 데이터를 처리하는 장치
  * 방대한 데이터를 저장하고, 자동적으로 계산
  * 입력, 제어, 기억, 연산, 출력 기능들을 갖추고 있음
  * 인류역사에 유례가 없는 발명품

---
## 컴퓨터로 할 수 있는 일

  * 복잡한 계산(미적분,통계)
  * 초정밀 그래픽 구현
  * 네트워크 통신

---
## 컴퓨터 구조 분야의 8가지 아이디어

  * 무어(Moore)의 법칙을 고려한 설계 (무어의 법칙: 시간에 흐름에 따른 컴퓨터의 발전 속도)
  * 설계를 단순화 하는 추상화 (컴퓨터의 자원이 늘어남에 따라 설계 시간이 길어지면서 탄생)
  * Common case fast
  * 병렬성을 통한 성능개선
  * 파이프라이닝을 통한 성능개선
  * 예측을 통한 성능 개선
  * 메모리 계층 구조
  * 여유분을 이용한 신용도 개선

---
## 무어의 법칙을 고려한 설계

  * 인텔의 창립자 중 한명인 고든 무어의 예측에서 유래
  * 18~24개월마다 칩에 집적되는 소자의 수가 2배가 된다는 법칙
  * 컴퓨터를 설계하는데에는 수년이 걸리기 때문에 집적되는 소자의 수가 2배 내지 4배가 증가함

---
## 설계를 단순화하는 추상화

  * 무어의 법칙에 따라 자원의 수가 급격하게 증가함
  * 설계시간이 길어 짐으로써 생산성이 낮아짐
  * 생산성을 높이기 위해여 추상화 개념을 사용
    + 추상화 : 단순한 것을 먼저 설계하고 나중에 자세한 것을 설계하는 것
    + 예 ) 고급언어 C언어, Python도 역시 추상화의 대표적인 예이다.
    + 원래 이해가 어려운 기계어로 이뤄져있지만 추상화하여 인간 사고적으로 만들어낸 것이 고급언어
  * 하위 수준의 상세한 사항을 안보이게 함으로써 상위 수준 모델을 단순화

---
## Common case fast
  * 자주 발생하는 일을 빠르게 처리하여 성능 향상 도모
  * Common case에 대한 최적화 및 단순화
  * Common case가 무엇인지 알고있다는 가정
  * Common case에 대한 세심한 실험과 측정 필요

---
## 병렬성을 통한 성능 개선
  * 컴퓨터 역사 초기부터 설계자들은 병렬성을 높여 성능을 끌어 올렸다.
  * 병렬성이란 큰 문제를 여러 개의 작은 문제로 나누어서 해결하는 방법
  * 병렬처리의 예 : 쓰레드(Thread)

---
## 파이프라이닝을 통한 성능 개선
  * 파이프라이닝은 병렬성의 특별한 형태
  * 처음 단계 출력이 다음 단계 입력으로 이어지는 구조
  * 화재를 진압하기 위해서 많은 사람들이 일렬로 늘어서 양동이를 나르는 것
   - 파이프라이닝의 예) 로봇 A,B,C,D
    + 로봇 A,B,C,D 가 따로 일을 한다면, A,B,C,D 가 처음부터 끝까지의 과정을 다 거쳐야한다.
    + 파이프라이닝 형식으로 한다면 A,B,C,D 가 각각의 역할을 분담하여 효율적으로 Task를 해결할 수 있다.
---
## 예측을 통한 성능 개선

  * 수요가 예상되는 부분을 예측
  * 복구비용이 작고, 성공확률이 높을 경우 효과적
  * 정확한 예측을 위한 지표가 필요함
---
## 메모리 계층구조

  * 메모리 계층구조를 통한 문제해결
  * 최상위 - 비싸고 제일 빠른 메모리
  * 최하위 - 느리고 값이 싼 메모리
    - 컴퓨터는 데이터를 접근할 때 최상단부터 최하단까지 내려가는데, '공간적 지역성' 원리에 따라 최상단에 최근에 접근했던 데이터를 위치시킨다.
    - 현재 컴퓨터는 상단부터 레지스터, 캐시 메모리, 램, 디스크 순으로 구성( 이러한 이치로 구성 )

---
## 여유분을 이용한 신용도 개선
  * 컴퓨터는 신뢰할 수 있어야함
  * 장애대처를 위한 여유분 준비
  * 데이터 손실 예방을 위한 백업과 같은 이치

---

## 컴퓨터의 구성요소

  * 입력(input) (예: 마우스, 키보드)
  * 출력(output) (예 : 모니터, 스피커)
  * 메모리(memory) (예: 하드디스크,RAM 등의 기억장치)
  * 데이터패스(data path)
  * 제어유닛(control)
    - 데이터패스 + 제어유닛 = CPU(Processor)

---

## 구성요소별 역할

  * 프로세서
    - 1) 메모리로부터 명령과 데이터를 얻음
    - 2) 제어유닛은 프로그램 명령에 따라서 데이터패스, 메모리, 입/출력의 동작을 결정함
  * 메모리
    - 1) 실질적으로 데이터 저장되는 공간
  * 입력
    - 1) 데이터를 메모리에 씀
  * 출력
    - 1) 메모리로부터 데이터를 읽음

---
## 프로세서의 역할: CPU

  * 메모리로부터 명령어를 받아와 제어신호를 생성
  * 컴퓨터 명령어(기계어)를 해석하고 연산함
  * 컴퓨터 기술을 이끄는 원동력
  * 인간의 두뇌와 같은 역할
---
## 프로세서의 역할: GPU(그래픽을 처리하기 위한 프로세서)

  * 픽셀로 이루어진 영상을 처리하는 용도로 탄생
  * 싱글코어보다 CPU보다 저성능이지만 병렬적인 수천개의 코어가 연결되어 있음
    - 그래서 가격도 CPU보다 훨씬 비쌈
  * 인공지능 기술발전의 선도주자

---
## 프로세서의 동작과정
  * 제어유닛(Control Unit,CU)
    - 명령어를 순서대로 실행할수 있도록 제어하는 장치
    - 주기억장치에서 프로그램 명령어를 꺼내 해독한다음 해독 결과에 따라서 제어 신호를 생성하고 생성된 신호를 주변 장치에게 보낸다.
    - 이들 주변장치가 보낸 신호를 받아서 다음 수행할 동작을 결정한다.
  * 레지스터(Register)
    - 레지스터는 중앙 처리 장치(cpu)의 처리속도와 비슷한 고속 기억 장치
    - 명령어 주소, 명령어 코드, 연산에 필요한 데이터, 연산 결과등을 임시로 저장하는 공간
      + 범용 레지스터 : 연산에 필요한 데이터, 연산 결과를 임시로 저장하는 레지스터
      + 특수 목적 레지스터 : 특별한 용도로 사용되는 레지스터
  * 산술/논리 연산장치(Arithmetic/Logic Unit,ALU)
![processor](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR8OAcVNgLcd9fTqD7XxrT8aLuPNHqoHFCGFPMP_C6bBO8i2nqa)

---
## 메모리의 역할

  * 메모리의 역할
    - 명령어(프로세스) 및 데이터 적재
      + 임시 기억 장치인 레지스터는 속도면에서 우월한 성능을 보이지만, 용량이 너무 작아서 만들어 진 것이 메모리
    - 정보를 저장해두었다가 필요할 때 읽어들이는 저장소
    - 레지스터의 용량이 너무 작아서 출시됨
    - RAM, ROM, 캐시 등

---

## 입력장치의 역할

  * 데이터를 입력하기 위한 컴퓨터의 외부장치
  * 키보드, 마우스, 스캐너 등

---
## 출력장치의 역할

  * 컴퓨터에서 처리된 결과를 출력해주는 장치
  * 모니터,프린터,스피커 등
    - 모니터는 GPU(그래픽 카드)에서 처리한 데이터를 출력하고 그 정도를 해상도라는 것으로 표현
    - 해상도라는 것은 화면에 나타나는 그림이나 글자의 선명도를 나타내는 정도
      + 1920 X 820 라는 것은 가로와 세로를 몇 개의 픽셀로 나타내는지를 보여줌. 가로 세로 1920개, 820개의 픽셀로 나타내는것
---

## 언어의 형태
  * 1. 고급 언어
    - 일반적으로 언급되는 프로그래밍 언어
    - C언어 , Python, Java 등
    - 고급언어를 컴파일러가 어셈블리어로 번역
      ```
      printf("hello world!")  //고급언어(C)
      ```

      ```
      mov eax,1
      push eax
      push DWARD "Hello world!"
      call printf
      ```

  * 2. 어셈블리어
    - 컴파일러로 부터 생성된 어셈블리어는 기계가 이해할 수 있는 형태로 번역됨
    - 기계사고방식의 언어
    - 어셈블러는 어셈블리어를 기계어로 번역
    ```
      mov eax,1
      push eax
      push DWARD "Hello world!"
      call printf  
      -> 1101001001000 ...
    ```

  * 3. 기계어
    - 기계어는 기수가 2인 숫자로 구성됨
    - 숫자 단위 하나는 비트(bit)
    - 컴퓨터가 이해할 수 있는 비트들의 집합

---
## 시스템 소프트웨어
    - 공통적으로 필요한 서비스를 제공하는 소프트웨어
    - 운영체제, 컴파일러, 로더, 어셈블러
    - 프로그램 - 하드웨어간의 인터페이스 역할

---
## High vs Low
 * high level language
  - 기계어를 고도로 추상화한 표현으로써 인간이 이해하기 쉬운 형태
  - 프로그램을 개발한 기종에 상관없이 어느 컴퓨터에서든 실행가능한 형태
    + 고급 언어 사이에서도 추상화 레벨에 따라 Low~high 레벨로 나뉨
    + 추상화 단계가 높을수록 한 개의 명령어에 더 많은 instruction이 생성된다.
    + 예로, python은 C언어보다 high level이므로 c언어보다 속도가 빠를 수 없다.
  - 컴파일 과정에서 불필요한 instruction이 생성되므로 다소 속도가 느림
    + 아무리 C언어로 코딩을 한다해도 어셈블리어로 코딩된 프로그램보다 속도가 빠를 수는 없다.
    + 왜냐하면 컴파일러가 instruction을 다 생성하는데 시간이 걸리고 그로 인해 용량이 커지기 때문이다.

  * low level language
    - 컴파일러나 어셈블리어가 생성하는 불필요한 instruction을 최소화 가능
      + 그러므로 용량이 매우 작고, 속도가 매우 빠르다.
      + 어셈블리어는 그 instruction을 직접 적어줘야하는 만큼 효율성이 떨어지는 언어이다.
    - 기계적 사고 방식을 강요하기 때문에 프로그램 구성을 위한 소요가 크다.

---

## 정리
  * 개발에 있어 고급언어가 효율적
  * 실행 속도에 있어 기계어가 효율적
  * CPU 기술 발전에 의하여 기계어와 고급언어 사이의 실행 속도 차이가 줆어듬

---
## 성능
  * 시간과 리소스에 대응되어 컴퓨터 시스템이 수행하는 작업의 양
  * 성능 측정 척도는 다양하다
  * 개인 사용자: 응답 시간(Response time)
  * 데이터 센터 관리자: 처리량(Throughput)

---
## 성능의 척도: 응답시간
  * 작업개시에서부터 종료까지의 시간
  * 디스크 접근, 메모리 접근, 입출력 작업, 운영체제 오버헤드, CPU 연산시간 등을 포함

## 성능의 척도: 처리량
  * 단위 시간당 처리할 수 있는 태스크의 양
  * 응답시간과는 다른 척도로 시스템 성능을 평가할 때 사용
  * 응답 시간을 단축시키면 대부분의 시스템에서 처리량은 증가한다.

## 성능과 실행시간과의 관계
  * 성능 x = 1 / 실행시간 x
  * 예 ) 같은 프로그램이 컴퓨터 A에서 10초 , B에서는 15초 걸린다면 A는 B보다 얼마나 빠른가?
    - 1.5배
---
## 클럭(Clock)
  * 하드웨어 이벤트가 발생하는 시점을 결정
  * 클럭 사이클: 클럭의 시간 간격
  * 클럭 속도: 클럭 사이클의 역수
---
## CPU 성능과 성능 인자
  * 궁극적인 CPU성능척도는 CPU시간
  * 프로그램의 CPU 실행시간 = 프로그램의 CPU클럭 사이클수 / 클럭 속도
  * 클럭사이클 수 = 명령어수 X 명령어당 평균 클럭 사이클수(CPI)
---
## CPI
  * CPI = Clock Per instruction
  * 명령어 하나의 실행에 필요한 평균 클럭 사이클 수
  * CPU 클럭 사이클 수 = 명령어수 X CPI
  * 프로그램 CPU 실행시간 = 명령어수 X CPI / 클럭 속도

---

## CPU 발전과정
  * 단일 프로세서 -> 멀티코어 프로세서
  * 멀티코어 프로세서란 여러 개의 코어를 집적한 프로세서
  * 파이프라인 구조를 채택하여 병렬성을 높이고 처리량을 최대화함

---
## CPU 발전과정
  * Intel 8086
    - 최초의 16bit 프로세서
    - PC가 많이 보급되지 않아 성공에는 실패함
    - 가성비가 떨어져 아케이드판, 콘솔쪽에도 채용되지 못함.
  * Intel 80386 CPU
    - 386이라는 이름으로 유명한 CPU (전설적인 CPU)
    - 뒤에 86이 붙은 프로세서를 intel x86 프로세서라고 칭함
    - 32bit 아키텍쳐로 이루어진 최초의 CPU
      + 32bit는 1클럭당 처리할 수 있는 최대 크기를 의미한다.
      + 32bit 환경에서는 메모리가 4GB이상으로 늘어나지 않는다.
      + 1Byte = 8bit , 32 bit = 4Byte
      + 1Byte(8bit)는 16진수로 00 ~ FF 까지 표현이 가능하다. 그러므로 4Byte(32bit)는 16진수로 00 00 00 00 ~ FF FF FF FF 까지 표현이 가능하다.
      + FF FF FF FF = 4,294,967,295 , 4GB(10진수로) 4 * 1024 * 1024 = 4,294,967,296
      + 둘은 '1' 차이가 남. 이는 컴퓨터가 숫자를 0부터 세기 때문
      + 즉, 32bit 주소체계의 최대치가 4GB값과 동일하기 때문에 메모리의 양 또한 4GB로 제한된다.
    - PC의 보급화로 전세계적으로 널리 사용됨

    * 펜티엄
      - 숫자대신 최초로 이름을 갖게된 CPU
      - 클럭속도 : 60MHz ~ 300MHz
      - 슈퍼스칼라 아키텍쳐 채용
        + 슈퍼스칼라 아키텍쳐란? 파이프 라인 2개를 이용해서 한 클럭당 여러개의 명령어가 수행되게끔 하는 구조

    * Intel 코어 2
      - 최초의 멀티코어 프로세서
      - 클럭 속도 : 1GHz ~ 3.33GHz
      - 코어 개수: 1,2,4

    * Intel i3/i5/i7
      - i3 - 2코어 4스레드
      - i5 - 4코어 4스레드
      - i7 - 4코어 8스레드
        + 'i3 빠르다', 'i5가 빠르다' 답을 내릴 수는 없지만, 대표적으로 멀티코어를 지원하지 않는 게임(롤, 피파, 서든 등등) 을 위해 PC를 사용한다면 i3, 검은사막, 오버워치 ,패키지게임 등 멀티코어를 지원하는 게임을 한다면 i5를 선택하는게 이상적인 선택이다.
        + 숫자가 높을수록 가격이 비싸다.
      - 하이퍼 스레딩(소프트 웨어적으로 하나의 코어에 또 다른 하나의 가상 코어를 만들어서 CPU가 사실은 하나지만, 두 개로 인식하게 만드는 병렬화 방법)
        + 하이퍼 스레딩이 적용된 프로세서에는 i3가 있다.
      - 오버클럭(4790K,7800K)
        + FSB,CPU의 배수를 안정적인 최대 운영 주파수에 도달할 때까지 높인다.
        + 오버클럭을 하게되면 전력을 훨씬 많이 소비하게 되지만, 높은 사양의 소프트웨어를 사용할 수 있다.
        + 하지만 전력이 높은 만큼 발열도 심하고, 하드웨어에 많은 무리가 간다.

    * i5-9600k 의 의미?!
      - i5 - brand modifier - 등급
      - [9]600 - Gen Indicator - 세대
      - 9[600] - SKU Numeric Digits - 모델명
      - K - Product Line Suffix - 용도 구분
        + 숫자 9는 세대를 의미. 인텔은 1~2년에 한 번씩 업그레이드된 cpu를 내놓는데 그 세대를 의미한다. 현재 9세대 이름은 미정이고 8세대는 커피레이크라는 이름으로 불린다.
        + 600은 모델명을 의미한다.
        + k는 용도를 뜻한다. k는 오버클럭 즉, 회사에서 내놓은 한계치보다 더 높게 cpu를 강제로 가동시킨 것.
        + T - 초 저전력 모델, U - 저전력(Ultra-low power), H - High Performance Graphics , Y - 저전력 모바일용 , Q - Quad core, X - 익스트림 최상급 cpu 등 많은 용도를 가진다.
---
## 암달의 법칙
  * 트랜지스터의 증가로 인한 성능향상에 한계점 도달
  * 코어 개수를 늘리는 방향으로 CPU의 진화
  * 코어가 두배가 된다고해서 성능이 두배가 되는 것은 아님.
  * 병렬화 문제에서 기인하여 프로세서 개수만으로는 성능향상에 한계점이 생김.

---
## 명령어(Instruction)의 정의
  * 컴퓨터가 하드웨어에게 일을 시키기 위한 수단
  * 명령어는 하향식 접근 구조 (고급 언어와 같이 위에서 아래 차례로 실행)
  * 다음 명령어를 가르키는 레지스터(Instruction Pointer)에 따라서 명령어를 실행함

## Instruction Pointer
  * 현재 실행되고 있는 프로그램의 실행코드가 저장된 메모리의 주소가 가르키는 상태 레지스터
  * 프로그램의 실행이 진행됨에 따라 자동으로 증가함
  * 프로그램의 실행 순서가 변경되는 제어문이 실행될 때 자동으로 변경됨 (if,for,while 을 만났을 때 어셈블리어 레벨에서는 instruction pointer가 조건이 참이 되는 코드를 가리킨다.)
  * 직접접근이 불가한 레지스터 (Ex . 제품키 입력 구간 우회 방지 등 )

---
## 명령어 집합구조(Instruction Set Architecture)
  * 프로세서가 인식해서 기능을 이해하고 실행할 수 있는 기계어
  * 명령어 집합구조는 1대1 대응되는 어셈블리로 표현 가능함
  * 명령어 집합구조에는 MIPS(32bit),ARM,x86,RISC-V 등이 있다.
    - Intel x86 : Intel 구 버전의 CPU 명령어 세트 => 32bit용 (64bit 환경에서도 동작은 한다)
    - Intel 64bit : 64비트 CPU라는 점에서 따온 것
    - AMD : Pentium이라는 이름으로 명명
---
## 명령어 집합구조(ISA) 설계
  * 명령어 집합 구조는 작성된 프로그램과 그 프로그램을 수행할 컴퓨터 하드웨어 사이의 인터페이스에 대한 완전한 정의 혹은 명세
    - C언어에서 printf라는 구문을 컴파일 하려고 할 때 명령어 집합 구조 내에 존재하는 조합으로 컴파일 할 수 없는 경우가 존재한다면 아무도 이 명령어 구조를 쓰지 않을 것이다.
  * 하드웨어 기술이나 컴퓨터의 구성, 플랫폼이 될 운영체제등을 고려해야 하는 매우 어려운 작업

  * 연산의 종류 :
    - 처리연산,제어연산,입출력연산 등
  * 데이터 형식(Data Type):
    - 데이터의 의미, 데이터 값 저장방식(정수,실수,논리) 등
  * 명령어 형식 (Instruction Type):
    - 명령어 구성부분을 나타내는 양식
  * 피연산자를 위한 주소지정 방식(Addressing Mode):
    - 피연산자의 위치를 명시하는 방법
    - 메모리 or 레지스터

---
## 명령어의 구조
  * 명령어는 크게 두 부분, 실행코드(opcode)와 피연산자(operand) 부분으로 구성함.
  ![opcode_operand](https://image.slidesharecdn.com/operandandopcode-170428104857/95/operand-and-opcode-computer-science-6-638.jpg?cb=1497422996)
  > 출처 : https://www.google.co.kr/url?sa=i&source=images&cd=&cad=rja&uact=8&ved=2ahUKEwiOqfSDw9LfAhVDT7wKHbddAjwQjRx6BAgBEAU&url=https%3A%2F%2Fwww.slideshare.net%2Ftransweb%2Foperand-and-opcode-computer-science&psig=AOvVaw0aiyu4FbUTXio-0gRuZyLp&ust=1546636191886048

---
## 산술 연산
  * 산술연산은 덧셈, 뺄셈, 곱셈, 나눗셈의 사칙연산의 계산을 하는 것
  * 컴퓨터는 레지스터와 ALU를 통해 산술연산을 수행
---
## MIPS 산술명령어
  * MIPS 산술명령어는 반드시 한종류의 연산만 지시
  * MIPS 산술명령어는 항상 변수 세개를 갖는 형식
  * 피연산자가 반드시 3개인 이유
    - 간단하게 설계하기 위해서는 규칙적인 것이 좋음
    - 간단하지만 최적화된 명령어 실행 구조
  * c언어에서 b,c,d,e 의 합을 a에 넣는경우,
    - add a,b,c # b와 c를 더하여 a에 저장 // a = b + c : a,b,c 세 개의 피연산자를 가진다.
    - add a,a,d # a와 d를 더하여 a에 저장 // a = a + d
    - add a,a,e # a와 e를 더하여 a에 저장 // a = a + e
    - 실제로는 레지스터 값이 피연산자의 값으로 들어감
---
## MIPS 레지스터
  * 연산을 위하여 MIPS 명령어구조에서 제공하는 레지스터
  * 레지스터는 컴퓨터가 사용하는 변수라고 이해하면 편함
  ![MIPS_Register](https://t1.daumcdn.net/cfile/tistory/162F11114CB6F62444)
  * 가장 많이 사용되는 레지스터는 t,s이다. s에는 보통 변수가 저장되고 , t는 임시적으로 저장된 값과 메모리에서 불러온 값이 저장된다.
  * v라는 레지스터는 어떤 함수의 반환 값이 return a+b; 라고 했을 때 a+b 값을 저장하는 레지스터이다.
  * sp,fp 레지스터
    - 함수가 실행될 때는 함수를 처리하기 위한 sp(스택프레임)이라는 공간으로 이동한다. sp는 스택 프레임내에 데이터가 증가할 때마다 값이 증가하는 포인터
    - fp는 스택 프레임의 시작위치를 알려주는 베이스 포인터

---
## 스택 프레임
  * 함수가 실행될 때마다 자신만의 고유한 stack 영역을 가질 수 있다.
  * 함수의 스택프레임 시작점은 fp가 가르킨다.
  * 함수의 종료시에 해제되고 리턴 주소로 복귀한다.

```c
int add(int a, int b){
  return a+b;
}

int main(){
  printf("%d",add(3,4));
  printf("hello world!\n");
  return 0;
}
```
  * add 함수의 인자인 3,4가 스택 프레임으로 들어가고 스택 포인터(sp)는 4를 가리키고 있을 것이다. fp(return 주소)가 0x00 이라면 3,4의 위치는 int 형이므로 0x04 , 0x08이 될 것이다. add 함수는 두 정수(3,4)를 받아서 연산을 한 후에 결과값을 v레지스터에 저장한다. 그 후 ra레지스터를 통해 add함수가 호출되기 직전의 코드로 돌아간다.

---
## 고급언어와의 관계
  * A = B + C;
  * D = A - E;
  * A~E는 $s1~$s5에 저장되어있다고 가정 (변수는 보통 s 레지스터에 저장)
  * add $s1,$s2,$s3
  * sub $s4,$s1,$s5

---
## 피연산자(operand)
  * 연산자의 정의된 연산을 하기 위하여 사용되는 레지스터나 상수, 레이블, 메모리 주소 등을 뜻하는 말
  * 레지스터는 데이터를 저장하는 장치중 속도가 가장 빠른 장소이므로 일부 레지스트만 사용 가능.
  * 더 적은 레지스터를 필요로 하는 순서로 연산을 함으로써 더 많은 피연산자를 레지스터에 할당할 수 있게 된다.

---
## 피연산자 데이터 단위
  * word : 32 bit
  * half word : 16bit
  * byte = 8 bit
  > MIPS 명령어(Instruction) 및 레지스터는 32비트로 구성되어 있다.
  > 연산자(op code) 1byte, 피연산자(operand) 3byte

---
## 연습 문제
  * &s0 = F, &s1 = G , &s2 = H, &s3 = I, &s4 = J 일때,
  > F = (G+H)-(I+J) ----MIPS----> ?

  * 계산한 값을 임시적으로 저장할때는 t 레지스터를 사용한다. 즉, G+H값을 $t0, I+J 값을 $t1에 저장한다
  ```
  add $t0,&s1,&s2 # t0 = g+h, s1 = g, s2 = h  //s1+s2 값을 t0에 저장
  add $t1,&s3,&s4 # t1 = i+j, s3 = i, s4 = j  //s3+s4 값을 t1에 저장
  sub $s0,&t0,&t1 # s0 = f, t0 = g+h, t1 = i+j //t0-t1 값을 s0에 저장
  ```
---
## 메모리 피연산자
