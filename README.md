# 컴퓨터 구조
## 컴퓨터의 정의

  * 전자 회로를 이용하여 데이터를 처리하는 장치
  * 방대한 데이터를 저장하고, 자동적으로 계산
  * 입력, 제어, 기억, 연산, 출력 기능들을 갖추고 있음
  * 인류역사에 유례가 없는 발명품

---
## 컴퓨터로 할 수 있는 일

  * 복잡한 계산(미적분,통계)
  * 초정밀 그래픽 구현
  * 네트워크 통신

---
## 컴퓨터 구조 분야의 8가지 아이디어

  * 무어(Moore)의 법칙을 고려한 설계 (무어의 법칙: 시간에 흐름에 따른 컴퓨터의 발전 속도)
  * 설계를 단순화 하는 추상화 (컴퓨터의 자원이 늘어남에 따라 설계 시간이 길어지면서 탄생)
  * Common case fast
  * 병렬성을 통한 성능개선
  * 파이프라이닝을 통한 성능개선
  * 예측을 통한 성능 개선
  * 메모리 계층 구조
  * 여유분을 이용한 신용도 개선

---
## 무어의 법칙을 고려한 설계

  * 인텔의 창립자 중 한명인 고든 무어의 예측에서 유래
  * 18~24개월마다 칩에 집적되는 소자의 수가 2배가 된다는 법칙
  * 컴퓨터를 설계하는데에는 수년이 걸리기 때문에 집적되는 소자의 수가 2배 내지 4배가 증가함

---
## 설계를 단순화하는 추상화

  * 무어의 법칙에 따라 자원의 수가 급격하게 증가함
  * 설계시간이 길어 짐으로써 생산성이 낮아짐
  * 생산성을 높이기 위해여 추상화 개념을 사용
    + 추상화 : 단순한 것을 먼저 설계하고 나중에 자세한 것을 설계하는 것
    + 예 ) 고급언어 C언어, Python도 역시 추상화의 대표적인 예이다.
    + 원래 이해가 어려운 기계어로 이뤄져있지만 추상화하여 인간 사고적으로 만들어낸 것이 고급언어
  * 하위 수준의 상세한 사항을 안보이게 함으로써 상위 수준 모델을 단순화

---
## Common case fast
  * 자주 발생하는 일을 빠르게 처리하여 성능 향상 도모
  * Common case에 대한 최적화 및 단순화
  * Common case가 무엇인지 알고있다는 가정
  * Common case에 대한 세심한 실험과 측정 필요

---
## 병렬성을 통한 성능 개선
  * 컴퓨터 역사 초기부터 설계자들은 병렬성을 높여 성능을 끌어 올렸다.
  * 병렬성이란 큰 문제를 여러 개의 작은 문제로 나누어서 해결하는 방법
  * 병렬처리의 예 : 쓰레드(Thread)

---
## 파이프라이닝을 통한 성능 개선
  * 파이프라이닝은 병렬성의 특별한 형태
  * 처음 단계 출력이 다음 단계 입력으로 이어지는 구조
  * 화재를 진압하기 위해서 많은 사람들이 일렬로 늘어서 양동이를 나르는 것
   - 파이프라이닝의 예) 로봇 A,B,C,D
    + 로봇 A,B,C,D 가 따로 일을 한다면, A,B,C,D 가 처음부터 끝까지의 과정을 다 거쳐야한다.
    + 파이프라이닝 형식으로 한다면 A,B,C,D 가 각각의 역할을 분담하여 효율적으로 Task를 해결할 수 있다.
---
## 예측을 통한 성능 개선

  * 수요가 예상되는 부분을 예측
  * 복구비용이 작고, 성공확률이 높을 경우 효과적
  * 정확한 예측을 위한 지표가 필요함
---
## 메모리 계층구조

  * 메모리 계층구조를 통한 문제해결
  * 최상위 - 비싸고 제일 빠른 메모리
  * 최하위 - 느리고 값이 싼 메모리
    - 컴퓨터는 데이터를 접근할 때 최상단부터 최하단까지 내려가는데, '공간적 지역성' 원리에 따라 최상단에 최근에 접근했던 데이터를 위치시킨다.
    - 현재 컴퓨터는 상단부터 레지스터, 캐시 메모리, 램, 디스크 순으로 구성( 이러한 이치로 구성 )

---
## 여유분을 이용한 신용도 개선
  * 컴퓨터는 신뢰할 수 있어야함
  * 장애대처를 위한 여유분 준비
  * 데이터 손실 예방을 위한 백업과 같은 이치

---

## 컴퓨터의 구성요소

  * 입력(input) (예: 마우스, 키보드)
  * 출력(output) (예 : 모니터, 스피커)
  * 메모리(memory) (예: 하드디스크,RAM 등의 기억장치)
  * 데이터패스(data path)
  * 제어유닛(control)
    - 데이터패스 + 제어유닛 = CPU(Processor)

---

## 구성요소별 역할

  * 프로세서
    - 1) 메모리로부터 명령과 데이터를 얻음
    - 2) 제어유닛은 프로그램 명령에 따라서 데이터패스, 메모리, 입/출력의 동작을 결정함
  * 메모리
    - 1) 실질적으로 데이터 저장되는 공간
  * 입력
    - 1) 데이터를 메모리에 씀
  * 출력
    - 1) 메모리로부터 데이터를 읽음

---
## 프로세서의 역할: CPU

  * 메모리로부터 명령어를 받아와 제어신호를 생성
  * 컴퓨터 명령어(기계어)를 해석하고 연산함
  * 컴퓨터 기술을 이끄는 원동력
  * 인간의 두뇌와 같은 역할
---
## 프로세서의 역할: GPU(그래픽을 처리하기 위한 프로세서)

  * 픽셀로 이루어진 영상을 처리하는 용도로 탄생
  * 싱글코어보다 CPU보다 저성능이지만 병렬적인 수천개의 코어가 연결되어 있음
    - 그래서 가격도 CPU보다 훨씬 비쌈
  * 인공지능 기술발전의 선도주자

---
## 프로세서의 동작과정
  * 제어유닛(Control Unit,CU)
    - 명령어를 순서대로 실행할수 있도록 제어하는 장치
    - 주기억장치에서 프로그램 명령어를 꺼내 해독한다음 해독 결과에 따라서 제어 신호를 생성하고 생성된 신호를 주변 장치에게 보낸다.
    - 이들 주변장치가 보낸 신호를 받아서 다음 수행할 동작을 결정한다.
  * 레지스터(Register)
    - 레지스터는 중앙 처리 장치(cpu)의 처리속도와 비슷한 고속 기억 장치
    - 명령어 주소, 명령어 코드, 연산에 필요한 데이터, 연산 결과등을 임시로 저장하는 공간
      + 범용 레지스터 : 연산에 필요한 데이터, 연산 결과를 임시로 저장하는 레지스터
      + 특수 목적 레지스터 : 특별한 용도로 사용되는 레지스터
  * 산술/논리 연산장치(Arithmetic/Logic Unit,ALU)
![processor](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR8OAcVNgLcd9fTqD7XxrT8aLuPNHqoHFCGFPMP_C6bBO8i2nqa)

---
## 메모리의 역할

  * 메모리의 역할
    - 명령어(프로세스) 및 데이터 적재
      + 임시 기억 장치인 레지스터는 속도면에서 우월한 성능을 보이지만, 용량이 너무 작아서 만들어 진 것이 메모리
    - 정보를 저장해두었다가 필요할 때 읽어들이는 저장소
    - 레지스터의 용량이 너무 작아서 출시됨
    - RAM, ROM, 캐시 등

---

## 입력장치의 역할

  * 데이터를 입력하기 위한 컴퓨터의 외부장치
  * 키보드, 마우스, 스캐너 등

---
## 출력장치의 역할

  * 컴퓨터에서 처리된 결과를 출력해주는 장치
  * 모니터,프린터,스피커 등
    - 모니터는 GPU(그래픽 카드)에서 처리한 데이터를 출력하고 그 정도를 해상도라는 것으로 표현
    - 해상도라는 것은 화면에 나타나는 그림이나 글자의 선명도를 나타내는 정도
      + 1920 X 820 라는 것은 가로와 세로를 몇 개의 픽셀로 나타내는지를 보여줌. 가로 세로 1920개, 820개의 픽셀로 나타내는것
---

## 언어의 형태
  * 1. 고급 언어
    - 일반적으로 언급되는 프로그래밍 언어
    - C언어 , Python, Java 등
    - 고급언어를 컴파일러가 어셈블리어로 번역
      ```
      printf("hello world!")  //고급언어(C)
      ```

      ```
      mov eax,1
      push eax
      push DWARD "Hello world!"
      call printf
      ```

  * 2. 어셈블리어
    - 컴파일러로 부터 생성된 어셈블리어는 기계가 이해할 수 있는 형태로 번역됨
    - 기계사고방식의 언어
    - 어셈블러는 어셈블리어를 기계어로 번역
    ```
      mov eax,1
      push eax
      push DWARD "Hello world!"
      call printf  
      -> 1101001001000 ...
    ```

  * 3. 기계어
    - 기계어는 기수가 2인 숫자로 구성됨
    - 숫자 단위 하나는 비트(bit)
    - 컴퓨터가 이해할 수 있는 비트들의 집합

---
## 시스템 소프트웨어
    - 공통적으로 필요한 서비스를 제공하는 소프트웨어
    - 운영체제, 컴파일러, 로더, 어셈블러
    - 프로그램 - 하드웨어간의 인터페이스 역할

---
## High vs Low
 * high level language
  - 기계어를 고도로 추상화한 표현으로써 인간이 이해하기 쉬운 형태
  - 프로그램을 개발한 기종에 상관없이 어느 컴퓨터에서든 실행가능한 형태
    + 고급 언어 사이에서도 추상화 레벨에 따라 Low~high 레벨로 나뉨
    + 추상화 단계가 높을수록 한 개의 명령어에 더 많은 instruction이 생성된다.
    + 예로, python은 C언어보다 high level이므로 c언어보다 속도가 빠를 수 없다.
  - 컴파일 과정에서 불필요한 instruction이 생성되므로 다소 속도가 느림
    + 아무리 C언어로 코딩을 한다해도 어셈블리어로 코딩된 프로그램보다 속도가 빠를 수는 없다.
    + 왜냐하면 컴파일러가 instruction을 다 생성하는데 시간이 걸리고 그로 인해 용량이 커지기 때문이다.

  * low level language
    - 컴파일러나 어셈블리어가 생성하는 불필요한 instruction을 최소화 가능
      + 그러므로 용량이 매우 작고, 속도가 매우 빠르다.
      + 어셈블리어는 그 instruction을 직접 적어줘야하는 만큼 효율성이 떨어지는 언어이다.
    - 기계적 사고 방식을 강요하기 때문에 프로그램 구성을 위한 소요가 크다.

---

## 정리
  * 개발에 있어 고급언어가 효율적
  * 실행 속도에 있어 기계어가 효율적
  * CPU 기술 발전에 의하여 기계어와 고급언어 사이의 실행 속도 차이가 줆어듬

---
## 성능
  * 시간과 리소스에 대응되어 컴퓨터 시스템이 수행하는 작업의 양
  * 성능 측정 척도는 다양하다
  * 개인 사용자: 응답 시간(Response time)
  * 데이터 센터 관리자: 처리량(Throughput)

---
## 성능의 척도: 응답시간
  * 작업개시에서부터 종료까지의 시간
  * 디스크 접근, 메모리 접근, 입출력 작업, 운영체제 오버헤드, CPU 연산시간 등을 포함

## 성능의 척도: 처리량
  * 단위 시간당 처리할 수 있는 태스크의 양
  * 응답시간과는 다른 척도로 시스템 성능을 평가할 때 사용
  * 응답 시간을 단축시키면 대부분의 시스템에서 처리량은 증가한다.

## 성능과 실행시간과의 관계
  * 성능 x = 1 / 실행시간 x
  * 예 ) 같은 프로그램이 컴퓨터 A에서 10초 , B에서는 15초 걸린다면 A는 B보다 얼마나 빠른가?
    - 1.5배
---
## 클럭(Clock)
  * 하드웨어 이벤트가 발생하는 시점을 결정
  * 클럭 사이클: 클럭의 시간 간격
  * 클럭 속도: 클럭 사이클의 역수
---
# CPU 성능과 성능 인자
  * 궁극적인 CPU성능척도는 CPU시간
  * 프로그램의 CPU 실행시간 = 프로그램의 CPU클럭 사이클수 / 클럭 속도
  * 클럭사이클 수 = 명령어수 X 명령어당 평균 클럭 사이클수(CPI)
---
# CPI
  * CPI = Clock Per instruction
  * 명령어 하나의 실행에 필요한 평균 클럭 사이클 수
  * CPU 클럭 사이클 수 = 명령어수 X CPI
  * 프로그램 CPU 실행시간 = 명령어수 X CPI / 클럭 속도

---
#0
